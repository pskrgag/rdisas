use elf::endian::AnyEndian;
use elf::file::*;
use elf::section::SectionHeaderTable;
use elf::symbol::Symbol;
use elf::ElfBytes;

pub struct Functions<'a> {
    list: Vec<(&'a str, Symbol)>,
}

impl<'a> Functions<'a> {
    pub fn new(list: Vec<(&'a str, Symbol)>) -> Self {
        Self { list: list }
    }

    // refs didn't work.... I am too dumbat rust
    pub fn names(&self) -> Vec<String> {
        self.list.iter().map(|x| x.0.to_owned()).collect()
    }
}

pub struct Elf<'a> {
    object: bool,
    data: ElfBytes<'a, AnyEndian>,
    sections: Option<SectionHeaderTable<'a, AnyEndian>>,
}

impl<'a> Elf<'a> {
    pub fn new(data: &'a [u8]) -> Option<Self> {
        let data = match ElfBytes::<AnyEndian>::minimal_parse(data) {
            Ok(o) => Some(o),
            Err(e) => {
                error!("Failed to parse file {}", e);
                None
            }
        }?;

        Self::check_header(&data)?;

        Some(Self {
            data: data,
            sections: None,
        })
    }

    pub fn load_sections(&mut self) -> Option<()> {
        self.sections = Some(self.data.section_headers()?);
        Some(())
    }

    fn check_header(e: &ElfBytes<AnyEndian>) -> Option<()> {
        let hdr = e.ehdr;

        match hdr.class {
            Class::ELF64 => Some(()),
            _ => {
                error!("Elf header class is not 64bit");
                None
            }
        }?;

        match hdr.e_machine {
            183 | 62 => Some(()),
            other => {
                error!("Does not support {}", other);
                None
            }
        }?;

        Some(())
    }

    pub fn function_names(&self) -> Option<Functions> {
        const ELF_SYM_STT_FUNC: u8 = 2;

        if let Ok(Some((symtab, strtab))) = self.data.symbol_table() {
            Some(Functions::new(
                symtab
                    .iter()
                    .map(|sym| (strtab.get(sym.st_name as usize).unwrap_or("unknown"), sym))
                    .filter(|s| s.1.st_symtype() == ELF_SYM_STT_FUNC)
                    .collect::<Vec<(&str, Symbol)>>(),
            ))
        } else {
            None
        }
    }

    pub fn func_code(&self, name: &String) -> &[u8] {
        match self.data.ehdr.e_type {
            elf::abi::ET_REL => self.func_code_reloc(name),
            elf::abi::ET_DYN | elf::abi::ET_EXEC => self.func_code_exe(name),
            _ => unsafe { unreachable!() },
        }
    }

    pub fn func_code_reloc(&self, name: &String) -> &[u8] {
        const ELF_SYM_STT_FUNC: u8 = 2;

        let (symtab, strtab) = self
            .data
            .symbol_table()
            .expect("Failed to get symbol table")
            .unwrap();

        for i in symtab {
            if i.st_symtype() == ELF_SYM_STT_FUNC {
                if strtab.get(i.st_name as usize).unwrap() == name {
                    return &self
                        .data
                        .section_data(&self.sections.unwrap().get(i.st_shndx as usize).unwrap())
                        .unwrap()
                        .0[i.st_value as usize..i.st_size as usize];
                }
            }
        }

        todo!();
    }

    pub fn func_code_exe(&self, name: &String) -> &[u8] {
        const ELF_SYM_STT_FUNC: u8 = 2;

        let (symtab, strtab) = self
            .data
            .symbol_table()
            .expect("Failed to get symbol table")
            .unwrap();

        let mut data = None;

        for i in symtab {
            if let Some((s, _)) = data {
                return &self
                    .data
                    .section_data(&self.sections.unwrap().get(i.st_shndx as usize).unwrap())
                    .unwrap()
                    .0[s as usize..i.st_value as usize];
            }

            if i.st_symtype() == ELF_SYM_STT_FUNC && strtab.get(i.st_name as usize).unwrap() == name {
                    data = Some((i.st_value, i.st_shndx));
            }
        }

        return &self
            .data
            .section_data(
                &self
                    .sections
                    .unwrap()
                    .get(data.unwrap().1 as usize)
                    .unwrap(),
            )
            .unwrap()
            .0[data.unwrap().0 as usize..];
    }
}
